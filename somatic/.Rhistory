for (i in 1:20) {
tableOfValues <- table(round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i)
if(sum(tableOfValues[which(tableOfValues > 100)]) / sum(tableOfValues) > 0.95) break
}
bedFile[,4] <- round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i
whichBedIsNA <- which(is.na(bedFile[,4]) | bedFile[,3] - bedFile[,2] < 80)
if (length(whichBedIsNA) > 0)
bedFile = bedFile[-whichBedIsNA,]
normal <- read.table(opt$normal, header=T, stringsAsFactors = F, comment.char="&" )
normal = normal
colnames(normal) = cutX(colnames(normal))
if (!startsWith(normal[,1], "chr"))
normal[,1] <- paste0("chr", normal[,1])
normal <- normal[order(normal[,1], as.numeric(normal[,2])),]
normal <- as.matrix(normal[,opt$colNum:ncol(normal)])
if (length(whichBedIsNA) > 0)
normal = normal[-whichBedIsNA,]
if (framework == "somatic") {
tumor <- read.table(opt$tumor, header=T, stringsAsFactors = F, comment.char="&" )
tumor = tumor
colnames(tumor) = cutX(colnames(tumor))
if (!startsWith(tumor[,1], "chr"))
tumor[,1] <- paste0("chr", tumor[,1])
tumor <- tumor[order(tumor[,1], as.numeric(tumor[,2])),]
tumor <- as.matrix(tumor[,opt$colNum:ncol(tumor)])
if (length(whichBedIsNA) > 0)
tumor = tumor[-whichBedIsNA,]
}
opt$bed = "/Users/gdemidov/Tuebingen/somatic_CNVs/Somatic/ssSC_v4.annotated.bed"
opt$normal = "/Users/gdemidov/Tuebingen/somatic_CNVs/Somatic/ontarget_v4.cov"
opt$colNum = 4
opt$out = "/Users/gdemidov/Tuebingen/clinCNV_dev/results"
opt$folderWithScript = "/Users/gdemidov/Tuebingen/clinCNV_test/ClinCNV/somatic"
setwd(opt$folderWithScript)
source("generalHelpers.R")
### PLOTTING OF PICTURES (DOES NOT REALLY NECESSARY IF YOU HAVE IGV SEGMENTS)
plottingOfPNGs = F
if (!dir.exists(opt$out)) {
dir.create(opt$out)
}
framework = "germline"
if (!is.null(opt$tumor)) {
print("Tumor file was provided. Framework is switched to somatic.")
framework = "somatic"
}
frameworkOff = "ontarget"
if (!is.null(opt$tumorOfftarget) & !is.null(opt$normalOfftarget) & !is.null(opt$bedOfftarget)) {
print("Offtarget files are provided. We try to utilise off-target coverage also.")
frameworkOff = "offtarget"
}
frameworkDataTypes = "covdepth"
if (!is.null(opt$bafFolder)) {
print("Folder with BAFs were provided. Framework swithced to BAF.")
frameworkDataTypes = "covdepthBAF"
}
### PART WITH LIBRARIES
library(robustbase)
library(MASS)
library("data.table")
library(foreach)
library(doParallel)
library(mclust)
no_cores <- min(detectCores() - 1, 4)
no_cores = 4
cl<-makeCluster(no_cores, type="FORK")
registerDoParallel(cl)
### READING DATA
setwd(opt$folderWithScript)
bedFile <- read.table(opt$bed, stringsAsFactors = F, sep="\t", comment.char="&", header=F)
if (!startsWith(bedFile[,1], "chr"))
bedFile[,1] <- paste0("chr", bedFile[,1])
colnames(bedFile) <- c("chr.X", "start", "end", "gc")
bedFile <- bedFile[order(bedFile$chr.X, as.numeric(bedFile$start)),]
for (i in 1:20) {
tableOfValues <- table(round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i)
if(sum(tableOfValues[which(tableOfValues > 100)]) / sum(tableOfValues) > 0.95) break
}
bedFile[,4] <- round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i
whichBedIsNA <- which(is.na(bedFile[,4]) | bedFile[,3] - bedFile[,2] < 80)
if (length(whichBedIsNA) > 0)
bedFile = bedFile[-whichBedIsNA,]
normal <- read.table(opt$normal, header=T, stringsAsFactors = F, comment.char="&" )
normal = normal
colnames(normal) = cutX(colnames(normal))
if (!startsWith(normal[,1], "chr"))
normal[,1] <- paste0("chr", normal[,1])
normal <- normal[order(normal[,1], as.numeric(normal[,2])),]
normal <- as.matrix(normal[,opt$colNum:ncol(normal)])
if (length(whichBedIsNA) > 0)
normal = normal[-whichBedIsNA,]
if (framework == "somatic") {
tumor <- read.table(opt$tumor, header=T, stringsAsFactors = F, comment.char="&" )
tumor = tumor
colnames(tumor) = cutX(colnames(tumor))
if (!startsWith(tumor[,1], "chr"))
tumor[,1] <- paste0("chr", tumor[,1])
tumor <- tumor[order(tumor[,1], as.numeric(tumor[,2])),]
tumor <- as.matrix(tumor[,opt$colNum:ncol(tumor)])
if (length(whichBedIsNA) > 0)
tumor = tumor[-whichBedIsNA,]
}
if (frameworkOff == "offtarget") {
bedFileOfftarget <- read.table(opt$bedOfftarget, stringsAsFactors = F, sep="\t")
if (!startsWith(bedFileOfftarget[,1], "chr"))
bedFileOfftarget[,1] <- paste0("chr", bedFileOfftarget[,1])
colnames(bedFileOfftarget) <- c("chr.X", "start", "end", "gc")
bedFileOfftarget <- bedFileOfftarget[order(bedFileOfftarget[,1], as.numeric(bedFileOfftarget[,2])),]
for (i in 1:20) {
tableOfValues <- table(round(as.numeric(as.character(bedFileOfftarget[,4])) / i, digits = 2) * i)
if(sum(tableOfValues[which(tableOfValues > 100)]) / sum(tableOfValues) > 0.95) break
}
bedFileOfftarget[,4] <- round(as.numeric(as.character(bedFileOfftarget[,4])) / i, digits = 2) * i
normalOff <- read.table(opt$normalOfftarget, header=T, stringsAsFactors = F, comment.char="&" )
colnames(normalOff) = cutX(colnames(normalOff))
if (!startsWith(normalOff[,1], "chr"))
normalOff[,1] <- paste0("chr", normalOff[,1])
normalOff <- normalOff[order(normalOff[,1], as.numeric(normalOff[,2])),]
normalOff <- as.matrix(normalOff[,opt$colNum:ncol(normalOff)])
# remain only samples that are in Normal cohort
normalOff <- normalOff[,which(colnames(normalOff) %in% colnames(normal))]
tumorOff <- read.table(opt$tumorOfftarget, header=T, stringsAsFactors = F, comment.char="&" )
colnames(tumorOff) = cutX(colnames(tumorOff))
if (!startsWith(tumorOff[,1], "chr"))
tumorOff[,1] <- paste0("chr", tumorOff[,1])
tumorOff <- tumorOff[order(tumorOff[,1], as.numeric(tumorOff[,2])),]
tumorOff <- as.matrix(tumorOff[,opt$colNum:ncol(tumorOff)])
# remain only samples that are in Tumor cohort
tumorOff <- tumorOff[,which(colnames(tumorOff) %in% colnames(tumor))]
}
getwd()
dim(normal)
dim(bedFile)
coverage <- sqrt(as.matrix(normal))
print("Gender determination started")
genderOfSamples <- Determine.gender(coverage, bedFile)
clusterExport(cl, c('EstimateModeSimple', 'bedFile', 'genderOfSamples', 'coverage', "lehmanHodges", 'Qn'))
bandwidths <- parSapply(cl=cl, 1:nrow(coverage), function(i) {x=coverage[i,];
if (bedFile[i,1] == "chrX" & length(which(genderOfSamples=="F")) >= 5) {x = x[which(genderOfSamples == "F")]};
if (bedFile[i,1] == "chrY" & length(which(genderOfSamples=="M")) >= 5) {x = x[which(genderOfSamples == "M")]};
density(x, bw="SJ")$bw})
bandwidths[which(bandwidths > quantile(bandwidths, 0.975))] = quantile(bandwidths, 0.975)
bandwidths <- parSapply(cl=cl, 1:nrow(coverage), function(i) {x=coverage[i,];
if (bedFile[i,1] == "chrX" & length(which(genderOfSamples=="F")) >= 5) {x = x[which(genderOfSamples == "F")]};
if (bedFile[i,1] == "chrY" & length(which(genderOfSamples=="M")) >= 5) {x = x[which(genderOfSamples == "M")]};
density(x, bw="SJ")$bw})
dim(coverage)
genderOfSamples
bandwidths <- parSapply(cl=cl, 1:nrow(coverage), function(i) {x=coverage[i,];
if (bedFile[i,1] == "chrX" & length(which(genderOfSamples=="F")) >= 5) {x = x[which(genderOfSamples == "F")]};
if (bedFile[i,1] == "chrY" & length(which(genderOfSamples=="M")) >= 5) {x = x[which(genderOfSamples == "M")]};
density(x, bw="SJ")$bw})
plot(coverage[,1])
opt$bed = "/Users/gdemidov/Tuebingen/somatic_CNVs/Somatic/ssSC_v4.annotated.bed"
opt$normal = "/Users/gdemidov/Tuebingen/somatic_CNVs/Somatic/ontarget_v4.cov"
opt$colNum = 4
opt$out = "/Users/gdemidov/Tuebingen/clinCNV_dev/results"
opt$folderWithScript = "/Users/gdemidov/Tuebingen/clinCNV_test/ClinCNV/somatic"
setwd(opt$folderWithScript)
source("generalHelpers.R")
### PLOTTING OF PICTURES (DOES NOT REALLY NECESSARY IF YOU HAVE IGV SEGMENTS)
plottingOfPNGs = F
if (!dir.exists(opt$out)) {
dir.create(opt$out)
}
framework = "germline"
if (!is.null(opt$tumor)) {
print("Tumor file was provided. Framework is switched to somatic.")
framework = "somatic"
}
frameworkOff = "ontarget"
if (!is.null(opt$tumorOfftarget) & !is.null(opt$normalOfftarget) & !is.null(opt$bedOfftarget)) {
print("Offtarget files are provided. We try to utilise off-target coverage also.")
frameworkOff = "offtarget"
}
frameworkDataTypes = "covdepth"
if (!is.null(opt$bafFolder)) {
print("Folder with BAFs were provided. Framework swithced to BAF.")
frameworkDataTypes = "covdepthBAF"
}
### PART WITH LIBRARIES
library(robustbase)
library(MASS)
library("data.table")
library(foreach)
library(doParallel)
library(mclust)
no_cores <- min(detectCores() - 1, 4)
no_cores = 4
cl<-makeCluster(no_cores, type="FORK")
registerDoParallel(cl)
### READING DATA
setwd(opt$folderWithScript)
bedFile <- read.table(opt$bed, stringsAsFactors = F, sep="\t", comment.char="&", header=F)
if (!startsWith(bedFile[,1], "chr"))
bedFile[,1] <- paste0("chr", bedFile[,1])
colnames(bedFile) <- c("chr.X", "start", "end", "gc")
bedFile <- bedFile[order(bedFile$chr.X, as.numeric(bedFile$start)),]
for (i in 1:20) {
tableOfValues <- table(round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i)
if(sum(tableOfValues[which(tableOfValues > 100)]) / sum(tableOfValues) > 0.95) break
}
bedFile[,4] <- round(as.numeric(as.character(bedFile[,4])) / i, digits = 2) * i
whichBedIsNA <- which(is.na(bedFile[,4]) | bedFile[,3] - bedFile[,2] < 80)
if (length(whichBedIsNA) > 0)
bedFile = bedFile[-whichBedIsNA,]
normal <- read.table(opt$normal, header=T, stringsAsFactors = F, comment.char="&" )
normal = normal
colnames(normal) = cutX(colnames(normal))
if (!startsWith(normal[,1], "chr"))
normal[,1] <- paste0("chr", normal[,1])
normal <- normal[order(normal[,1], as.numeric(normal[,2])),]
normal <- as.matrix(normal[,opt$colNum:ncol(normal)])
if (length(whichBedIsNA) > 0)
normal = normal[-whichBedIsNA,]
if (framework == "somatic") {
tumor <- read.table(opt$tumor, header=T, stringsAsFactors = F, comment.char="&" )
tumor = tumor
colnames(tumor) = cutX(colnames(tumor))
if (!startsWith(tumor[,1], "chr"))
tumor[,1] <- paste0("chr", tumor[,1])
tumor <- tumor[order(tumor[,1], as.numeric(tumor[,2])),]
tumor <- as.matrix(tumor[,opt$colNum:ncol(tumor)])
if (length(whichBedIsNA) > 0)
tumor = tumor[-whichBedIsNA,]
}
if (frameworkOff == "offtarget") {
bedFileOfftarget <- read.table(opt$bedOfftarget, stringsAsFactors = F, sep="\t")
if (!startsWith(bedFileOfftarget[,1], "chr"))
bedFileOfftarget[,1] <- paste0("chr", bedFileOfftarget[,1])
colnames(bedFileOfftarget) <- c("chr.X", "start", "end", "gc")
bedFileOfftarget <- bedFileOfftarget[order(bedFileOfftarget[,1], as.numeric(bedFileOfftarget[,2])),]
for (i in 1:20) {
tableOfValues <- table(round(as.numeric(as.character(bedFileOfftarget[,4])) / i, digits = 2) * i)
if(sum(tableOfValues[which(tableOfValues > 100)]) / sum(tableOfValues) > 0.95) break
}
bedFileOfftarget[,4] <- round(as.numeric(as.character(bedFileOfftarget[,4])) / i, digits = 2) * i
normalOff <- read.table(opt$normalOfftarget, header=T, stringsAsFactors = F, comment.char="&" )
colnames(normalOff) = cutX(colnames(normalOff))
if (!startsWith(normalOff[,1], "chr"))
normalOff[,1] <- paste0("chr", normalOff[,1])
normalOff <- normalOff[order(normalOff[,1], as.numeric(normalOff[,2])),]
normalOff <- as.matrix(normalOff[,opt$colNum:ncol(normalOff)])
# remain only samples that are in Normal cohort
normalOff <- normalOff[,which(colnames(normalOff) %in% colnames(normal))]
tumorOff <- read.table(opt$tumorOfftarget, header=T, stringsAsFactors = F, comment.char="&" )
colnames(tumorOff) = cutX(colnames(tumorOff))
if (!startsWith(tumorOff[,1], "chr"))
tumorOff[,1] <- paste0("chr", tumorOff[,1])
tumorOff <- tumorOff[order(tumorOff[,1], as.numeric(tumorOff[,2])),]
tumorOff <- as.matrix(tumorOff[,opt$colNum:ncol(tumorOff)])
# remain only samples that are in Tumor cohort
tumorOff <- tumorOff[,which(colnames(tumorOff) %in% colnames(tumor))]
}
rowsToRemove <- cleanDatasetFromLowCoveredFiles(normal)
bedFile <- bedFile[-rowsToRemove,]
normal <- normal[-rowsToRemove,]
if (framework == "somatic")
tumor <- tumor[-rowsToRemove,]
if (frameworkOff == "offtarget") {
rowsToRemove <- cleanDatasetFromLowCoveredFiles(normalOff)
normalOff = normalOff[-rowsToRemove,]
tumorOff = tumorOff[-rowsToRemove,]
bedFileOfftarget = bedFileOfftarget[-rowsToRemove,]
}
### GC CONTENT NORMALIZATION
if (framework == "somatic") {
pairs <- read.table(opt$pair, sep=",", stringsAsFactors = F)
pairs <- data.frame(pairs, ncol=2)
pairs <- unique(pairs)
}
## CHECK INPUT VALIDITY
if (!is.null(opt$normalSample)) {
stopifnot(opt$normalSample %in% colnames(normal))
}
if (!is.null(opt$tumorSample)) {
stopifnot(!is.null(opt$normalSample))
stopifnot(opt$tumorSample %in% colnames(tumor))
stopifnot(opt$tumorSample %in% pairs[,1])
stopifnot(opt$normalSample %in% pairs[,2])
coordOfNormalInPairs = which(pairs[,2] == opt$normalSample)
stopifnot(opt$tumorSample %in% pairs[coordOfNormalInPairs,1])
}
lstOfChromBorders <- getCytobands("cytobands.txt")
left_borders <- lstOfChromBorders[[1]]
right_borders <- lstOfChromBorders[[2]]
ends_of_chroms <- lstOfChromBorders[[3]]
if (frameworkDataTypes == "covdepthBAF") {
setwd(opt$folderWithScript)
source("bafSegmentation.R",local=TRUE)
if (!dir.exists(file.path(opt$bafFolder, "/result"))) {
dir.create(file.path(opt$bafFolder, "/result"))
}
if (!is.null(opt$normalSample) & !is.null(opt$tumorSample)) {
coordOfNormalInPairs = which(pairs[,2] == opt$normalSample & pairs[,1] == opt$tumorSample)
pairsForBAF = pairs[coordOfNormalInPairs,,drop=F]
} else {
pairsForBAF = pairs
}
listOfValues <- returnAllowedChromsBaf(pairsForBAF, normal, tumor, opt$bafFolder, bedFile, left_borders, right_borders, ends_of_chroms)
allowedChromsBaf <- listOfValues[[1]]
bAlleleFreqsAllSamples <- listOfValues[[2]]
}
setwd(opt$folderWithScript)
### ON TARGET GC NORMALIZATION
if (max(bedFile[,3] - bedFile[,2]) / min(bedFile[,3] - bedFile[,2]) > 16)
normal <- lengthBasedNormalization(normal, bedFile)
lst <- gc_and_sample_size_normalise(bedFile, normal)
normal <- lst[[1]]
if (framework == "somatic") {
if (frameworkDataTypes == "covdepthBAF") {
if (max(bedFile[,3] - bedFile[,2]) / min(bedFile[,3] - bedFile[,2]) > 16)
tumor <- lengthBasedNormalization(tumor, bedFile, allowedChroms=allowedChromsBaf)
lst <- gc_and_sample_size_normalise(bedFile, tumor, allowedChroms=allowedChromsBaf)
} else {
tumor <- lengthBasedNormalization(tumor, bedFile)
lst <- gc_and_sample_size_normalise(bedFile, tumor)
}
tumor <- lst[[1]]
bedFile <- lst[[2]]
} else {
bedFile <- lst[[2]]
}
# checkSignalToNoise <- function(matr) {
#   mediansWithoutNorm <- apply(matr, 2, median)
#   sdsWithoutNorm <- apply(matr, 2, Sn)
#   return(mediansWithoutNorm / sdsWithoutNorm)
# }
# snNormWith = checkSignalToNoise(normal)
# snTumorWith = checkSignalToNoise(tumor)
# snNormWithout = checkSignalToNoise(normal)
# snTumorWithout = checkSignalToNoise(tumor)
### OFF TARGET GC NORMALIZATION
if (frameworkOff == "offtarget") {
lst <- gc_and_sample_size_normalise(bedFileOfftarget, normalOff)
normalOff <- lst[[1]]
if (frameworkDataTypes == "covdepthBAF") {
lst <- gc_and_sample_size_normalise(bedFileOfftarget, tumorOff, allowedChroms=allowedChromsBaf)
} else {
lst <- gc_and_sample_size_normalise(bedFileOfftarget, tumorOff)
}
tumorOff <- lst[[1]]
bedFileOfftarget <- lst[[2]]
}
### PROCESSING OF GERMLINE VARIANTS
setwd(opt$folderWithScript)
source("helpersGermline.R")
print("Processing of germline variants started.")
coverage <- sqrt(as.matrix(normal))
print("Gender determination started")
genderOfSamples <- Determine.gender(coverage, bedFile)
print("Gender succesfully determined. Plot is written in your results directory.")
clusterExport(cl, c('EstimateModeSimple', 'bedFile', 'genderOfSamples', 'coverage', "lehmanHodges", 'Qn'))
bandwidths <- parSapply(cl=cl, 1:nrow(coverage), function(i) {x=coverage[i,];
if (bedFile[i,1] == "chrX" & length(which(genderOfSamples=="F")) >= 5) {x = x[which(genderOfSamples == "F")]};
if (bedFile[i,1] == "chrY" & length(which(genderOfSamples=="M")) >= 5) {x = x[which(genderOfSamples == "M")]};
density(x, bw="SJ")$bw})
bandwidths[which(bandwidths > quantile(bandwidths, 0.975))] = quantile(bandwidths, 0.975)
#medians <- parSapply(cl=cl, 1:nrow(coverage), function(i) {EstimateModeSimple(coverage[i,], bedFile[i,1], FindRobustMeanAndStandardDeviation)})
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
dim(mediansAndSds)
dim(coverage)
medians = mediansAndSds[,1]
whichMediansAreSmall <- which(medians < 0.5 | mediansAndSds[,2] < 10**-5)
if (length(whichMediansAreSmall) > 0) {
coverage <- coverage[-whichMediansAreSmall,]
bedFile <- bedFile[-whichMediansAreSmall,]
medians <- medians[-whichMediansAreSmall]
mediansAndSds = mediansAndSds[-whichMediansAreSmall,]
}
coverage.normalised = sweep(coverage, 1, medians, FUN="/")
coverage.normalised <- coverage.normalised[, order((colnames(coverage.normalised)))]
clusterExport(cl, c('coverage.normalised', 'determineSDsOfGermlineProbe'))
sdsOfProbes1 = mediansAndSds[,2] / mediansAndSds[,1]
sdsOfProbes <- parSapply(cl=cl, 1:nrow(coverage.normalised), function(i) {determineSDsOfGermlineProbe(coverage.normalised[i,], i)})
plot(sdsOfProbes1 ~ sdsOfProbes)
abline(b=1,col="red")
abline(b=1,a=0,col="red")
sdsOfProbes = mediansAndSds[,2] / mediansAndSds[,1]
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
FindRobustMeanAndStandardDeviation <- function(x, bandwidth, genders, chrom, modeEstimated = NA) {
if (length(x) < 50) {
if (chrom != "") {
if (chrom %in% c("X", "Y", "chrX", "chrY")) {
if (is.null(genders)) {
x = x[which(x > median(x))]
} else {
if (chrom == "chrX") {
x = x[which(genders == "F")]
if (length(x) < 2) {
x = x[which(x > median(x))]
}
}
if (chrom == "chrY") {
x = sqrt(2) * x[which(genders == "M")]
if (length(x) < 2) {
return(1)
}
}
}
}
}
if (length(x) > 30 ){
mu = median(x)
} else {
mu = lehmanHodges(x)
}
if (mu < 0.3) {
mu = median(x)
}
return(mu, Qn(x))
}
if (chrom == "chrX") {
x = x[which(genders == "F")]
}
if (chrom == "chrY") {
x = x[which(genders == "F")]
}
density_of_x <-  density(x, bw=bandwidth, kernel="gaussian")
if (is.na(modeEstimated)) {
mu = density_of_x$x[which.max(density_of_x$y)]
} else {
mu = modeEstimated
}
closest_to_mu <- which.min(abs(density_of_x$x - mu))
which_are_bigger <- which(density_of_x$y > density_of_x$y[closest_to_mu])
density_of_x <- as.data.frame(cbind(density_of_x$x, density_of_x$y))
colnames(density_of_x) <- c("x","y")
density_of_x[which_are_bigger,] <- density_of_x$y[closest_to_mu]
EF = max(density_of_x$y)
lower_bound = min(density_of_x$x)
lower_bound_differs = F
bounded_on_lower_copy_nuber = which(density_of_x$x < sqrt(mu ** 2 - 1/4))
if (length(bounded_on_lower_copy_nuber) > 0) {
start_to_the_left <- max(bounded_on_lower_copy_nuber)
previous_value = density_of_x$y[start_to_the_left]
for (i in seq(from = start_to_the_left, to=1, by=-1)) {
AB =  density_of_x$y[i]
if ((AB > previous_value + 10**-10) | AB < 10**-10) {
lower_bound = density_of_x$x[i]
lower_bound_differs = T
break
} else {
previous_value = AB
}
}
}
upper_bound = max(density_of_x$x)
upper_bound_differs = F
bounded_on_higher_copy_nuber = which(density_of_x$x > sqrt(mu ** 2 + 1/4))
if (length(bounded_on_higher_copy_nuber) > 0) {
start_to_the_right <- min(bounded_on_higher_copy_nuber)
previous_value = density_of_x$y[start_to_the_right]
for (i in seq(from = start_to_the_right, to=length(density_of_x$x), by=1)) {
AB =  density_of_x$y[i]
if ((AB > previous_value + 10**-10 | AB < 10**-10)) {
upper_bound = density_of_x$x[i]
upper_bound_differs = T
break
} else {
previous_value = AB
}
}
}
if (upper_bound_differs & lower_bound_differs) {
dtnorm0 <- function(X, mean, sd, log = TRUE) {dtnorm(X, mean, sd, lower_bound, upper_bound,
log)}
} else if (!upper_bound_differs & !lower_bound_differs) {
return(matrix(c(median(x), Qn(x)), nrow=1))
} else if (upper_bound_differs) {
dtnorm0 <- function(X, mean, sd, log = FALSE) {dtnorm(X, mean, sd, lower = -10**10, upper=upper_bound,
log)}
} else {
dtnorm0 <- function(X, mean, sd, log = FALSE) {dtnorm(X, mean, sd, lower=lower_bound, upper=10**10,
log)}
}
QnX <- Qn(x)
data = x[which(x >= lower_bound & x <= upper_bound)]
if (is.na(modeEstimated)) {
result <- tryCatch({fitdistr(data, dtnorm0, start=list(mean=mean(data), sd=sd(data))); return(nres$estimate)}
, error = function(e) {return(matrix(c(mu, QnX), nrow=1))})
} else {
result <- tryCatch({fitdistr(data, dtnorm0, fix.arg=list(mean=modeEstimated), start=list(mean=modeEstimated, sd=sd(data))); return(nres$estimate)}
, error = function(e) {return(matrix(c(mu, QnX), nrow=1))})
}
# Sometimes we miss one cluster and that's cause to increase of standard deviation
result[2] = min(QnX, result[2], sd(x))
return(result)
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
mediansAndSds <- foreach(i=1:nrow(coverage), .combine="rbind") %dopar% {
FindRobustMeanAndStandardDeviation(coverage[i,], bandwidths[i], genderOfSamples, bedFile[i,1])
}
stopCluster()
stopCluster(cl)
